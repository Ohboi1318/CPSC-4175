## Homework 02 - Tristan Porter ##

#### 1. What is the first step in creating a piece of software? ####

Determining what the software should do.

#### 2. What is the difference in discovering what the client needs and discovering what the software should do? ####

Determining what the client needs involves talking with the client thoroughly to insure that all needs are correctly understood by both parties. Determining what the software should do takes those needs and applies them to the client's situation to determine how the client can be helped with their needs.

#### 3. In what sense is a software engineer a generalist rather than a specialist? ####

A software engineer is a generalist in the sense that he or she must be able to accommodate all kinds of software requirements and be able to implement them. If he or she is to specialized they may not be able to deliver what the client needs.

#### 4. List some techniques the book identifies as useful for determining requirements and for each, give one reason why that technique might not be effective. ###3

- Interviewing - If the people interviewed cannot accurately convey their needs than the requirements for the software cannot be ascertained
- Questionnaire - Response questions to answers given cannot be asked
- Direct Observation - Can be very time consuming for little result

#### 5. In what sense are requirements dynamic rather than static? ####

Requirements are dynamic because they are subject to change throughout the development process.

#### 6. In your own words, state the difference between functional and nonfunctional requirements. Do you think that there is any such thing as a nonfunctional requirement? ####

A functional requirement is something that the software should be able to do. A non-functional requirement is a property that must be applied to the software. Yes, I think that there is such thing as a non-functional requirement. They are a separate but important part of software development.

#### 7. What is top-down analysis ? You may also see this referred to as structured analysis. How is this different than the case study in chapter 11 in the book? ####

Top-down analysis is a type of analysis that involves starting with the overall software idea being developed and then continually breaking it down into smaller parts and in doing so deciding requirements and needs. This is different from the case study in the book, in which they use bottom-up analysis. They start with groups of requirements and then slowly group those groups together until they end up with just one group representing the overall goal of the software.

#### 8. Prototyping is a very controversial issue. Can you think of some reasons why many software engineers think that prototyping is harmful? ####

Focusing on speed diminishes the quality of the product. While it may eventually be improved upon to the level of quality required, it still rewards doing work faster over doing work better.

#### 9. Teams One and Two both have the responsibility for developing a software requirements specification for a project. Team One has infrequent changes to its requirements specification, while Team Two has very frequent changes to its requirements specification. Which team is doing the better job? Justify your answer. ####

Team One, this is because as your software is being developed new requirements and needed features may come to light. While the software requirements specification should definitely be as complete and correct as possible when the development starts, that does not mean that it should not change. However, it should not change too often. Changing too often reflects a poor software requirements specification from the start.

#### 10. More software defects are traceable to bad requirements analysis than to any other source. Why do you think this is true? ####

I think this is true because if your software requirements are incorrect, then in the end your software will not deliver what it is supposed to. Whereas, if the requirements had been corrects, then the only problems would be with the coding and development of the software and not what it ultimately delivers.