## Homework 07 - Tristan Porter ##

#### 1. Where, in the software construction process, should testing occur? Explain your reasoning. ####

I think that testing should always be occurring. This is because the software is constantly changing throughout the process and the software requirements themselves often change as well. Therefore the software should always be tested not only to ensure that it functions, but also that it still meets the most current requirements.

#### 2. Explain the differences and similarities between verification and validation. ####

Validation is concerned with ensuring that the software meets the customer's needs. Verification is ensuring that the software meets the requirements specification.

#### 3. Explain the difference between execution-based-testing and non-execution-based-testing. ####

Non-execution-based-testing is when the module being developed is reviewed by a team. This leads to faster fault detection. Execution-based-testing is when the module is run against test cases. This allows the module to be tested against the requirements specification.

#### 4. Discuss the concept of quality as that word is used in the phrase "software quality assurance." ####

The concept of quality in this case means how well the software being developed adheres to the guidelines of whichever set of guidelines the company uses. As well as how well it adheres to the requirements specification. These are weighed against how much code is being produced in how much time and how many bugs that software contains.

#### 5. Why should software not be tested by the implementors, and not implemented by the testers? Think of an illustration from your life experience (not necessarily IT related). ####

The people who implement the software are familiar with how it works and therefore may not run into any bugs that would be caused by someone who is using the software for the first time. The testers should not implement code because they should focus all of their time on finding bus and ensuring the quality of the code and making sure that it does what it required. For instance, in my games programming class, a group of my friends and i designed a board game. We could only write out so many rules but we knew how the game worked so we wrote what we thought would be unclear. However, as soon as someone outside of the group played it, they already had questions and found obscurities in our rules that we hadn't thought of.

#### 6. Explain the difference between correctness proofs and execution testing ? Which is "better?" Why? ####

Correctness proofs are mathematical proofs that show that a program will run correctly and yield the correct results. Execution testing is running the code against test cases to insure that the program works correctly. I think execution testing is better because it is more hands on. You are running the code against problems that it would eventually be put up against when implemented in the real world. Therefore you can more accurately test its ability to perform correctly.

#### 7. Read the article The Coming Software Apocalypse in the PDF directory. Wrote a one paragraph appreciation of the article. ####

The article talks about how just writing code is no longer a valid way to design software. This is because with millions of lines of code in the piece of software it becomes almost impossibly difficult to fix problems or even follow the code. Software developers have lost touch with the problems they are trying to solve and focus too much on coding the software to work. This leads to catastrophic failures such as with the 911 calls in Seattle or the accidents involving Toyota cars. This has all led to a starting of changing the way in which people code. Now we can see what our code does as we write it, keeping us in touch with our goals.

#### 8. In regard to that article, how do you see your role in addressing the concerns raised in that article? Do you really think that there will be a "software apocalypse?" ####

I'm not entirely sure that there will be a software apocalypse. But the concerns are definitely valid, coding is becoming a little out of base with what it is supposed to do. Software developers are missing huge problems such as with the 911 calls that would have been easily fixable. But they just assumed that they would never encounter that problem, so they didn't code a solution for it.